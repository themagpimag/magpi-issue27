The Matboard ProjectMatthew and Martin BrabhamFor MagPi1st August, 2014 The beginningMy son Matthew , when he was 8 years old was introduced to the Makey Makey in school by a team of engineers from IBM that were doing community work. He loved the way it was easy to develop software and connect to the real world. He even got a trip to IBM where he was shown the Raspberry Pi. As we began to talk about this at home, I began to tell Matthew about my own experiences with the ZX81 and ZX Spectrum.  I think these conversations got both of us interested in getting more involved in engineering. I had completed an engineering degree and had worked for an electronics manufacturer as part of the product development team for many years but I hadn’t written a single line of code since I left university.The Raspberry Pi arrived on Matthews 9th Birthday complete with all the accessories and a blank SD card. To be honest , having not done the research the first few days were disappointing. It took us most of the day to install Linux and make an LED go on and off on the expansion board we had purchased. This was no ZX spectrum it was a powerful and complex machine. Someone told me that a single Raspberry Pi has more computing power than the orginal space shuttle!!After playing a few of the Python games, we realised we wanted to do some control projects. Matthew started googling “GPIO Tutorials” and we were off to maplins to get ourselves some LEDS and Switches. From there we started controlling a few motors with relays and somewhere along the way we came up with the idea for a simple, easy to use GPIO expansion board that could be used by just about anyone.Of course we started on Veroboard and then at some point , after telling Matthew how PCBs were designed , we decided to go ahead and design one ourselves.Having looked around for software, we came across the Design Sparks package from RS components. This was great as it is was free, easy to use and came with a library of basic components.The first idea we had was that the board should have four coloured LEDs and switches so that a first time user without doing anything complicated could start to right easy programs. For example simulating a traffic light.  This would make the board suitable for young users just getting into computing.However we also wanted people to be able to go a bit further, so we included in the design four relays and four switch inputs, so that we could control and read things in the real world.As the Raspberry Pi as 3.3V logic and can supply a relatively small amount of current, we used an darlington pair buffer IC (ULN2803A) to turn on the relays and also to protect the Pi from damage.Sourcing the components presented many challenges, for example finding coloured switches, white LEDs and relays with low power consumption.We then had the idea to include a prototyping area with the Raspberry Pi I2C (SDA/SCL) pins and also space for a  power input connector.  We hoped that this would make the board interesting for both beginners and also slightly more advanced users.Prototype Area with DC-DC Converter and Real Time ClockOur Raspberry Pi could now be run from a battery, keep the time and control things anywhere. We were Mobile !!In fact it was working so well, and was so easy to use compared with other boards, we decided that other people might want to use it to. A friend of ours told me about Kickstarter and we decided to try and raise the funds to build 100 units or in money terms £ 1500 pounds.Before we could start this we need to come up with a name for the product, for a few weeks it was called the “Brabboard” but eventually we decided to call it the “Matboard”.Martin and Matthew in their home laboratoryThe first PCB (Model A) had a few design problems, due to some confusion on the relay manufacturers datasheet we had connected the relay coil in reverse. The board didn’t work!!It was time to introduce my son to electronics troubleshooting and re-work. Or as he likes to call it Hacking. Luckily it was only a double side board and we were able to drill out some tracks and add some wires! It didn’t look great but it worked, and we had a product.Our first project was taking the “Simulate” python game , changing the code to include GPIO inputs and outputs and then wiring the PCB into a box of arcade lights & buttons. It worked and we were feeling good.However we had made a few mistakes, aside from the relay issue , the PCB terminal block were too small and difficult to use, we had short circuit that had to be removed and the RPi mounting holes were too close to the relays to be useful.Lessons learned – always build a prototype!!We decide to design a model B, to fix all of the issues, add a silkscreen layer with clear labels for each GPIO pin and also connect the switches differently so they could be activated by either grounding the input or by a voltage (up to 30VDC).  We ended up also routing these through the ULN2803A. This gave the board the ability to read sensors with output voltages down to 2VDC.  We had also moved to a 4 layer PCB with power and ground planes to improve the layout of the board.The new PCB took 3 weeks to arrive, as we were using the lowest cost delivery. In fact we could have got in 2 days but that would have cost over £400 !! With the Model B working and the design finished, it was time to launch on Kickstarter.https://www.kickstarter.com/projects/900987827/matboard-a-easy-to-use-gpio-board-for-raspberry-piPutting the Kickstarter project together was also a lot of fun especially making the 90 second video with Matthew. It was also incredible how quickly we started to get enquiries and backers. Our first backer for the project was after only 10 minutes of being live!!At the beginning of course we were worried that we wouldnt get the funding , but after only 4 days we had over 40 backs and were 2/3 of the way to the £ 1500 goal.Along the way we had a lot of people make suggestions and send us messages of encouragement. One idea was that the GPIO connector would be more usable on the other side of the board, otherwise when the RPi is installed on top of the Matboard , the ribbon cable would block the LEDs and Switches.Matthew and I agreed, and decided that we would incorporate this suggestion, we were on Model C!After a hectic few days finishing the Model C design, we were ready to order the final prototype PCB.At the last minute , I came up with the idea of adding a couple of extra PCB holes that could provide extra 0V, 5V and 3.3V.  I did this quickly before work and then sent the files to the PCB manufacturer. It was to prove a big mistake, in my rush I had connected all of the power and ground planes together.A week into the order, we were looking at the PCB design when we spotted the error.  A horrible sickening feeling. The PCB manufacture was helpful but the PCB was already in manufacture, there was no choice but to fix it and order another board. The PCB company took pity on us and gave us a 5 day delivery service at the 3 week price, it was an expensive mistake but at least we were on track.The Kickstarter project finished and we exceeded our funding goal by over a thousand pound. 105 people mostly strangers had backed the project from all over the world.Now it was time to deliver the finished product. We have promised our backers that we will ship the Matboard kits by the end of August and we have a lot to do. when another hiccup happened just before we were about to order the components …The Raspberry Pi foundation announced the new Model B+ , which is great but we needed to understand what the implications were for the Matboard. The new model has a 40 Way GPIO connector compared to a 26W on the original Raspberry Pi.  We didn’t want to design a product that couldn’t be used with the new model.  We ordered the new Raspberry Pi and started to think what we should do.  The people backing the project, were presumably owners of RPi’s with 26Way connectors, so we needed a solution that would enable our backers to use the board and also we useful to future customers using the Model B+Luckily on the new Model B+ the first 26 GPIO Pins have exactly the same functions as the original unit. So we have decide to change the connector on the Matboard from a shrouded type to an open type , so that both 26W and 40W cables can be used.Now the Matboard will work with the B and B+ model Pi’s !!Future PlansFor the Matboard,  we will be finishing the first kits for our 100 backers at the end of August. We have also ordered some extra kits for us to sell online at our website www.wlabs.co.uk.We are also hoping to find some other interested companies to help us promote the MatboardWhat’s next?We are always thinking about new products and things to do with the raspberry pi and electronics in general. At the moment we are working on an led cube with 9 LEDs on each face that can be made to flash in sequence. Matthew is also working on his own project that’s a bit like skylanders which can have up to 2 players on the raspberry pi. What we’ve learntMatthewI have learnt about electronic components  and what they’re used for on the board. I have learnt several soldering skills , and can build a finished Matboard in 30 minutes. Also I know how to design a PCB. I have learnt programming skills like how to use a button with the GPIO .MartinFrom what I have seen the Raspberry Pi , has done a great job of getting Matthew involved in electronics and programming. It quite fascinating to see him come up with an idea, write the code and wire the Matboard into a project. The Tomato Watering ProjectWhen we are on holiday we needed a solution to water our tomatos in the greenhouse, having the neighbour pop round to do this seemed a bit too simple, so we created the setup below.The idea was to use water from a waterbutt that is near the greenhouse with a small 12V pump. Luckily our greenhouse is near the house , so we can pick up a strong WiFi signal.It uses a Python file that is executed at 18.01 pm every day by using the CRONTAB on the Raspberry Pi.  We then read a water level sensor that is mounted with lego bricks to determine if there is sufficient water to start the pump cycle. If the water level is low then a function is called to send an email from a gmail account informing you that the water level is low.If the water level is OK, a electronic valve opens and the pump runs for 2 minutes. This is connected to a plastic pipe with holes drilled in it , which works surprisingly well.After two minutes the valve closes and the pump stops. Without the valve we found that the siphon effect kicks in and empties the whole water butt into the green house (something else I learnt the hard way).Then the Python Code, executes a command to take a picture of the greenhouse and email it from the gmail account.The system is powered by a 24W AC-DC PSU that delivers 12V to power the pump and valve.A 12V to 5V dc-dc converter is installed on the prototype area, to tap off 5V for the RPi and Matboard to run from. We also used a DS1307+ Real Time Clock chip so that if we lose the WiFi connection and have any kind of power outage , the system can still keep time and activate at 18.01pm.We plan to add a few more features, that will use extra inputs and outputs of the Matboard over the next few months. PICTURESWATERING SYSTEM – Rpi, Matboard, 12V PSU and Camera installed in Waterproof BoxLego based Water Level SensorWaterbutt and Control SystemEmail sent from gmail , confirming watering and with a picture from the greenhousePUMP and Water ButtHere is a portion of the code for this project, that shows inputs being read by Matboard, Matboard Relay being activated, text and picture emails being sent, camera being activated from within Python. All useful stuff for people developing there own control projectsimport RPi.GPIO as GPIO, feedparserfrom time import sleepimport smtplib , osfrom email.mime.text import MIMETextfrom email.MIMEMultipart import MIMEMultipartfrom email.MIMEImage import MIMEImageGPIO.setwarnings(False)GPIO.setmode(GPIO.BOARD)#Set up GPIO Inputs#Yellow InputGPIO.setup(7, GPIO.IN)#Set up GPIO Outputs#Orange LEDGPIO.setup(12, GPIO.OUT)#Set LEDs to Off and outputs to FalseGPIO.output(12,False)#set up for gmailUSERNAME = "EMAILADDRESS"     # the gmail address before @PASSWORD = "EMAILPASSWORD"    Yellow_Status = 0Red_Status = 0def Send_nowater_email():    USERNAME = "EMAILADDRESS@gmail.com"    PASSWORD = "PASSWORD"    MAILTO  = "EMAILADDRESSYOUWANTTOMAILTO"    msg = MIMEText('Water Butt Empty')    msg['Subject'] = 'Water Butt Empty'    msg['From'] = USERNAME    msg['To'] = MAILTO    print "Water Butt empty email sent"    server = smtplib.SMTP('smtp.gmail.com:587')    server.ehlo_or_helo_if_needed()    server.starttls()    server.ehlo_or_helo_if_needed()    server.login(USERNAME,PASSWORD)    server.sendmail(USERNAME, MAILTO, msg.as_string())    server.quit()    print"email sent to:" + MAILTO    returndef Send_email():    print"sending image"    USERNAME = "cameraraspberrypi@gmail.com"    PASSWORD = "Raspberry3333"    MAILTO  = "martinandsandi@me.com"    msg = MIMEMultipart()    msg['Subject'] = 'Greenhouse Watered'    msg['From'] = USERNAME    msg['To'] = MAILTO    msg.attach(MIMEImage(file("/home/pi/water.jpg").read()))    print "Sent image"    server = smtplib.SMTP('smtp.gmail.com:587')    server.ehlo_or_helo_if_needed()    server.starttls()    server.ehlo_or_helo_if_needed()    server.login(USERNAME,PASSWORD)    server.sendmail(USERNAME, MAILTO, msg.as_string())    server.quit()    print"email sent to:" + MAILTO    returndef water_plants():    GPIO.output(12,True)    sleep(3)    GPIO.output(12,False)    returndef take_picture():    os.system("raspistill -o water.jpg -w 1024 -h 768 -q 30")        while True:    Input_yellow = GPIO.input(7)    print Input_yellow    if Input_yellow == False:        water_plants()        take_picture()        Send_email()        print"wait 30 seconds"        sleep(30)        print"exit program"        sys.exit()            if Input_yellow == True:        Send_nowater_email()        take_picture()        sys.exit()                              